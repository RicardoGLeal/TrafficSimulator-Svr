# -*- coding: utf-8 -*-
"""Simulacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lOT3GnlxqHBlllSZkRmj87jyGCRu6_Kk
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install mesa

from mesa import Agent, Model
from mesa.time import SimultaneousActivation
from mesa.space import SingleGrid, MultiGrid
from mesa.datacollection import DataCollector
import random
import itertools
import numpy as np
from random import randint

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import pandas as pd

"""Importing the data
grafo : 
"""
# conexiones = pd.read_csv("conexiones7.csv", index_col = [0]).to_dict("index")
# mapa = pd.read_csv("grafo.csv", header= None).values
# directions = {"AR":  [0,  1],
#               "AL":  [0, -1],
#               "BR":  [-1, 0], 
#               "BL":  [1,  0], 
#               "CR":  [0, -1], 
#               "CL":  [0,  1], 
#               "DR":  [1,  0],
#               "DL":  [-1, 0]
#               }

class Router:
    def __init__(self, current_position, destination_position, conexiones, map):

        self.current_position = current_position
        self.destination_position = destination_position
        self.conexiones = conexiones

        self.current_lane = self.__find_lane_from_coordinates(current_position)
        self.destination = self.__find_lane_from_coordinates(destination_position)

        self.directions = {"AR":  [0,  1],
                            "AL":  [0, -1],
                            "BR":  [-1, 0], 
                            "BL":  [1,  0], 
                            "CR":  [0, -1], 
                            "CL":  [0,  1], 
                            "DR":  [1,  0],
                            "DL":  [-1, 0]
                            }

        self.map = map
        self.target_direction = None
        self.target_final_direction = None
        self.target_intersection = None
        self.target_lane = None
        self.target_position = None
    

    def findConnection(self):
        sectionA = self.current_lane[:2]
        quadrantB =self.destination[:1]
        
        for i in range(1, 4):
            neighboor = f"{sectionA}{i}"
            lanes = self.conexiones[neighboor]["Carriles"]
            
            if self.destination in lanes:
                direction = self.directions[sectionA]
                intersection = [self.conexiones[neighboor][f"{quadrantB}x"], self.conexiones[neighboor][f"{quadrantB}y"]]
                position = [self.conexiones[neighboor]["end_x"], self.conexiones[neighboor]["end_y"]]

                self.target_direction = direction
                self.target_final_direction = self.directions[self.destination[:2]]
                self.target_intersection = intersection
                self.target_lane = neighboor
                self.target_position = position
                 

                return [neighboor, position, direction, intersection]

        #print("Unable to find a route to the destination")
        return 
    
    
    def __find_lane_from_coordinates(self, coordinates):

        for key, element in self.conexiones.items():
            start_x, end_x, start_y, end_y = element["start_x"], element["end_x"], element["start_y"], element["end_y"]
            
            bounds_x = sorted([start_x, end_x])
            bounds_y = sorted([start_y, end_y])

            is_x_in_bounds = self.__is_in_bounds(coordinates[0], bounds_x)
            is_y_in_bounds = self.__is_in_bounds(coordinates[1], bounds_y)


            if start_x == end_x and coordinates[0] == start_x and is_y_in_bounds:
                return key
            if start_y == end_y and coordinates[1] == start_y and is_x_in_bounds:
                return key
        return 
    
    def __is_in_bounds(self, element, bounds):
        
        return (bounds[0] <= element and element <= bounds[1])

def generate_coords(secciones, n, start_section = "A", end_section = "C"):
    start_points = random.sample(set(itertools.product(range(*secciones[start_section]["x"]),range(*secciones[start_section]["y"] ))), n)
    end_points = random.sample(set(itertools.product(range(*secciones[end_section]["x"]),range(*secciones[end_section]["y"] ))), n)
    return start_points, end_points

def generate_coords(start_lanes, end_lanes, distributions, n ):
    start_points = []
    end_points   = []

    for content in start_lanes.values():
        start_points += random.sample(set(itertools.product(range(*content["x"]),range(*content["y"] ))), n)
        ratios = (distributions/np.sum(distributions) * n).astype(int)
        for idx, end_content in enumerate(end_lanes.values()):
            # print(idx, end_content)
            end_points += random.sample(set(itertools.product(range(*end_content["x"]), range(*end_content["y"] ))), ratios[idx])


    # end_points = random.sample(set(itertools.product(range(*secciones[end_section]["x"]),range(*secciones[end_section]["y"] ))), n)
    # print(start_points, end_points)
    return start_points, end_points

def rand_sum_k(totals):
    a = np.random.random((6, 4))  # create random numbers
    a = a/np.sum(a, axis=0) * totals  # force them to sum to totals

    # Ignore the following if you don't need integers
    a = np.round(a)  # transform them into integers
    remainings = totals - np.sum(a, axis=0)  # check if there are corrections to be done
    for j, r in enumerate(remainings):  # implement the correction
        step = 1 if r > 0 else -1
        while r != 0:
            i = np.random.randint(6)
            if a[i,j] + step >= 0:
                a[i, j] += step
                r -= step
    print(a)


def get_status_grid(model, mapa):
    result = mapa.copy()
    for (content, x, y) in model.grid.coord_iter():
        for elem in content:
            if isinstance(elem, CellAgent):
                result[x][y] = 8
    return result

class CellAgent(Agent):
    """An agent with fixed initial wealth."""
    def __init__(self, unique_id, model, final_destination, conexiones, mapa):
        super().__init__(unique_id, model)
        self.state = 1 # 1 -- alive, 0 -- dead
        self.next_state = 1
        print("Routning, ", (unique_id), final_destination)
        self.router = Router(list(reversed(unique_id)), final_destination, conexiones, mapa)
        self.route = self.router.findConnection()
        self.route_available = self.route is not None
        #if self.route_available:
            #print(self.router.current_lane, self.router.destination)
        self.next_step = 0
        self.final_destination = final_destination

    def step(self):
        if self.route_available:
            alive_neighbors = 0
            neighbors = self.model.grid.get_neighborhood(
                (self.pos),
                moore=True,
                include_center=False
        )
            
            vector = [0,0]
            new_position = list(self.pos)
            if (self.pos[0] == self.router.target_position[1] and self.pos[1] == self.router.target_position[0]):
                # print("uuid: ", self.unique_id, self.pos, self.router.target_position )
                # print("uuid: ", self.unique_id )
                self.next_step = 1
            if (self.pos[0] == self.router.target_intersection[1] and self.pos[1] == self.router.target_intersection[0]):
                # print("uuid: ", self.unique_id )
                self.next_step = 2
            
            if (self.pos[1] == self.final_destination[0]):
                self.next_step =3

            if self.next_step ==0:
                if self.pos[0] < self.router.target_position[1]:
                    vector[0] += self.router.target_direction[1]

                    if self.pos[1] < self.router.target_position[0]:
                        vector[1] += 1
                    elif self.pos[1] > self.router.target_position[0]:
                        vector[1] -= 1
                    front = self.willCrash([new_position[0]+vector[0],new_position[1]])
                    side = self.willCrash([new_position[0],new_position[1] + vector[1]])
                    top_diagonal = self.willCrash([new_position[0] + vector[1],new_position[1] + vector[1]])
                    bottom_diagonal = self.willCrash([new_position[0] - vector[1],new_position[1] + vector[1]])

                    if not top_diagonal and not side:
                        new_position[0]+=vector[0]
                        new_position[1]+=vector[1]
                    elif not side and not bottom_diagonal:
                        new_position[1]+=vector[1]
                    elif not front:
                        new_position[0]+=vector[0]

                    if not self.model.grid.out_of_bounds(new_position):
                        self.model.grid.move_agent(self, tuple(new_position))
                elif self.pos[0] == self.router.target_position[1]:
                    
                    if self.pos[1] < self.router.target_position[0]:
                        vector[1] += 1
                    elif self.pos[1] > self.router.target_position[0]:
                        vector[1] -= 1

                    side = self.willCrash([new_position[0],new_position[1] + vector[1]])
                    top_diagonal = self.willCrash([new_position[0] + vector[1],new_position[1] + vector[1]])
                    bottom_diagonal = self.willCrash([new_position[0] - vector[1],new_position[1] + vector[1]])
                    #print("Should I go left", [new_position[0],new_position[1] + vector[1]], top_diagonal, bottom_diagonal)
                    if not side and not bottom_diagonal:
                        new_position[1]+=vector[1]
                    if not self.model.grid.out_of_bounds(new_position):
                        self.model.grid.move_agent(self, tuple(new_position))



            if self.next_step == 1:
                #print(self.unique_id)
                if self.checkForLight():
                    
                    front = self.willCrash([new_position[0]+self.router.target_direction[1], new_position[1]])
                    right = self.willCrash([new_position[0], new_position[1]+1])
                    left = self.willCrash([new_position[0], new_position[1]-1])
                    #print("front : ", left, self.pos, self.router.target_intersection, [new_position[0], new_position[1]-1])
                    # print("ios this true? : ", self.pos[0] < self.router.target_intersection[1] and not front)
                    # print(self.pos, self.router.target_intersection)
                    if self.pos[0] < self.router.target_intersection[1]:
                        if not front:
                            new_position[0] += self.router.target_direction[1]
                    elif self.pos[1]< self.router.target_intersection[0] and not right:
                        new_position[1] += 1
                    elif self.pos[1] > self.router.target_intersection[0] and not left:
                        #print("Going left")
                        new_position[1] -= 1

                    if not self.model.grid.out_of_bounds(new_position):
                        self.model.grid.move_agent(self, tuple(new_position))
            if self.next_step ==2:
                #print("Last step")
                left = self.willCrash([new_position[0], new_position[1]-1])
                right = self.willCrash([new_position[0], new_position[1]+1])
                if self.pos[1] > self.final_destination[0]:
                    if not left:
                        if not self.model.grid.out_of_bounds([new_position[0], new_position[1]-1]):
                            self.model.grid.move_agent(self, tuple([new_position[0], new_position[1]-1]))
                elif self.pos[1] < self.final_destination[0]:
                    if not left:
                        if not self.model.grid.out_of_bounds([new_position[0], new_position[1]-1]):
                            self.model.grid.move_agent(self, tuple([new_position[0], new_position[1]-1]))
            #if self.next_step == 3:
             #   print("Good-bye")


            
    
    def willCrash(self, new_position):
        cellmates = self.model.grid.get_cell_list_contents([new_position])
        # print("Cell", cellmates)
        for mate in cellmates:
            if type(mate) is CellAgent:
                return bool(self.router.map[new_position[1], new_position[0]])

        return False
    
    def checkForLight(self):
        return True


class CruceroModel(Model):
    """A model with some number of agents."""
    def __init__(self, N, M):
        conexiones = pd.read_csv("conexiones7.csv", index_col = [0]).to_dict("index")
        mapa = pd.read_csv("grafo.csv", header= None).values

        self.directions = {"AR":  [0,  1],
              "AL":  [0, -1],
              "BR":  [-1, 0], 
              "BL":  [1,  0], 
              "CR":  [0, -1], 
              "CL":  [0,  1], 
              "DR":  [1,  0],
              "DL":  [-1, 0]
              }
        
        rand_sum_k(np.array([5]))

        router = Router((0, 8),(3,7), conexiones, mapa)
        router.findConnection()

        self.num_agents = 1
        self.grid = MultiGrid(N, M, False)
        self.schedule = SimultaneousActivation(self)
        self.num = 0
        self.vehiculos = []
        secciones = {"A":{"x": [7,10], "y":[0, 6]}, "D": {"x": [0, 5], "y": [7,9]}}
        # secciones = {"A":{"x": [7,10], "y":[0, 6]}, "D": {"x": [0, 5], "y": [7,9]}}
        start_points, end_points = self.__generate_coords(secciones, 5)

        index = 0
        for start, end in zip(start_points, end_points):
            #print(start, end)
            router=  Router(start, end, conexiones, map)
            router.findConnection()
            #print(router.current_lane, router.destination)
            a = CellAgent(tuple(reversed(start)), self, end, conexiones, mapa)

            self.schedule.add(a)
            self.vehiculos.append(a)
            self.grid.place_agent(a, tuple(reversed(start)))

        self.datacollector = DataCollector(
            model_reporters={"Grid": lambda x : get_status_grid(self, mapa)}
        )


    def step(self):
        """Advance the model by one step."""
        print(f'Iteracion {self.num}')
        self.num += 1
        self.datacollector.collect(self)
        self.schedule.step()

    
    def __generate_coords(self, secciones, n):
        
        start_points = random.sample(set(itertools.product(range(*secciones["A"]["x"]),range(*secciones["A"]["y"] ))), n)
        end_points = random.sample(set(itertools.product(range(*secciones["D"]["x"]),range(*secciones["D"]["y"] ))), n)
        return start_points, end_points

    def status_agentes(self):
        data = []
        for v in self.vehiculos:
            print("pos: ",str(v.pos))
            data.append({'carroID': v.unique_id, 'wayPointID': 21 * v.pos[0] + v.pos[1]})
        return data


# Invoke model

# mapa = pd.read_csv("grafo.csv", header= None).values
# new_model = CruceroModel(*mapa.shape)
# Iterations = 40

# for i in range(Iterations):
#   new_model.step()

# data = new_model.datacollector.get_model_vars_dataframe()
# print(data.to_string())

# fig, axs = plt.subplots(figsize=(7,7))
# patch = plt.imshow(data.iloc[0][0], cmap=plt.cm.binary)

# def animate(index):
#   patch.set_data(data.iloc[index][0])

# anim = animation.FuncAnimation(fig, animate, frames=Iterations)
# from IPython.display import HTML
"""carro
-carril:0
-posicion:0
"""